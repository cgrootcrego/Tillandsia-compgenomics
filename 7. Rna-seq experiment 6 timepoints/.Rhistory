datExpr = datExpr0[keepSamples, ]
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
datTraits <- metadata[-c(12,36),]
datTraits <- data.frame(sample=c(rep(1,6), rep(2,6), rep(3,6),
rep(4,6),rep(5,6), rep(6,6)),
time=c(rep(c(1,2,3,4,5,6),6)))
View(datTraits)
datTraits <- datTraits[-c(12,36),]
rownames(datTraits) <- rownames(datExpr)
# Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(datTraits),
main = "Sample dendrogram and trait heatmap")
# Saving data ready for network construction
save(datExpr, datTraits, file = "coexpression_input_Tfas_vsd_10c12s_2.RData")
library("WGCNA")
# Set necessary environment for WGCNA
options(stringsAsFactors = FALSE);
allowWGCNAThreads()
# Load input data
lnames = load(file = "coexpression_input_Tfas_vsd_10c12s_2.RData");
# Choosing the soft threshold
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))
# Call the network topology analysis function, I decided to choose a signed network
# signed network: direction of correlation is integrated (positive vs negative)
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5, networkType = "signed")
# Load input data
lnames = load(file = "coexpression_input_Tfas_vsd_10c12s_2.RData");
# Based on what I have read, one should choose a power that maintains an R^2 as high as
# possible and a mean connectivity between 30 and 100. Therefore, I chose a soft-thresholding
# power of 18, where R^2 is 0.74200 and the mean connectivity is 42.10
softPower = 18;
# Building the ajacency and Topological Overlap Matrix - this is the co-expression network
adjacency = adjacency(datExpr, power = softPower, type = "signed")
TOM = TOMsimilarity(adjacency);
dissTOM = 1-TOM
# Gene clustering
# Call the hierarchical clustering function
geneTree = hclust(as.dist(dissTOM), method = "average");
# Plot the resulting clustering tree (dendrogram)
sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
labels = FALSE, hang = 0.04)
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 30;
# Module identification using dynamic tree cut:
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
deepSplit = 2, pamRespectsDendro = FALSE,
minClusterSize = minModuleSize);
table(dynamicMods)
sum(dynamicMods)
?TOMsimilarity()
dynamicMods
sum(table(dynamicMods))
# We end up with 119 modules, the largest one contains 642 genes, the smallest
# contains 48 genes. Now we display the modules under the dendrogram.
# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Plot the dendrogram and colors underneath
sizeGrWindow(8,6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene dendrogram and module colors")
# Merge modules with very similar expression, anything with a correlation higher than 85 %.
# This reduces the number of modules from 103 to 83.
# Calculate eigengenes
MEList = moduleEigengenes(datExpr, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average");
# Plot the result
sizeGrWindow(7, 6)
plot(METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")
# Threshold for merging modules
MEDissThres = 0.15
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
# Call an automatic merging function
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs;
sizeGrWindow(12, 9)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
# Threshold for merging modules
MEDissThres = 0.2
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
# Call an automatic merging function
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs;
sizeGrWindow(12, 9)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
# Rename to moduleColors - not really sure what this does
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;
# Save module colors and labels for use in subsequent parts
save(MEs, moduleLabels, moduleColors, geneTree, file = "coexpression_network_Tfas_vsd_10c12s_2.RData")
# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
xLabels = names(datTraits),
yLabels = names(MEs),
ySymbols = names(MEs),
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.3,
zlim = c(-1,1),
main = paste("Module-trait relationships"))
#Gather some info on significant modules
modules_sign_time <- as.data.frame(moduleTraitCor[moduleTraitPvalue[,2] < 0.05,])
View(modules_sign_time)
nr_genes_module <- table(moduleColors)
nr_genes_module[substring(rownames(modules_sign_time),3)]
# Threshold for merging modules
MEDissThres = 0.15
# Call an automatic merging function
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs;
sizeGrWindow(12, 9)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
# Rename to moduleColors - not really sure what this does
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;
# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
#Gather some info on significant modules
modules_sign_time <- as.data.frame(moduleTraitCor[moduleTraitPvalue[,2] < 0.05,])
View(modules_sign_time)
nr_genes_module <- table(moduleColors)
nr_genes_module[substring(rownames(modules_sign_time),3)]
sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
xLabels = names(datTraits),
yLabels = names(MEs),
ySymbols = names(MEs),
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.3,
zlim = c(-1,1),
main = paste("Module-trait relationships"))
# Now I want to focus just on time differences
time = as.data.frame(datTraits$time);
names(time) = "time"
# names (colors) of the modules
modNames = substring(names(MEs), 3)
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
geneTraitSignificance = as.data.frame(cor(datExpr, time, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
names(geneTraitSignificance) = paste("GS.", names(time), sep="");
names(GSPvalue) = paste("p.GS.", names(time), sep="")
# Plot for each gene in the module the relationship between module membership
# (i.e. how strongly the gene belongs to the module) and its significance for time
# (correlation of expression and time, not actually a p-value)
module = "lightyellow"
# Plot for each gene in the module the relationship between module membership
# (i.e. how strongly the gene belongs to the module) and its significance for time
# (correlation of expression and time, not actually a p-value)
module = "deeppink"
column = match(module, modNames);
moduleGenes = moduleColors==module;
sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
abs(geneTraitSignificance[moduleGenes, 1]),
xlab = paste("Module Membership in", module, "module"),
ylab = "Gene significance for time",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
modules_sign_time$gene_count <- nr_genes_module[substring(rownames(modules_sign_time),3)]
lnames <- load(file = "coexpression_network_Tfas_vsd_10c12s..RData");
# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
#Gather some info on significant modules
modules_sign_time <- as.data.frame(moduleTraitCor[moduleTraitPvalue[,2] < 0.05,])
colnames(modules_sign_time) <- c("corr_to_sample", "corr_to_time")
nr_genes_module <- table(moduleColors)
modules_sign_time$gene_count <- nr_genes_module[substring(rownames(modules_sign_time),3)]
View(moduleTraitPvalue)
modules_sign_time$pvalue_sample <- moduleTraitPvalue[rownames(modules_sign_time),1]
modules_sign_time$pvalue_time <- moduleTraitPvalue[rownames(modules_sign_time),2]
?save
write.csv(modules_sign_time, file = "Table_modules_sign_time_Tfas.csv", quote = F, sep = "\t")
setwd('/home/clara/Documents/GitHub/Tillandsia-compgenomics/7. Rna-seq experiment 6 timepoints/')
# Set necessary environment for WGCNA
options(stringsAsFactors = FALSE);
allowWGCNAThreads()
# Load input data
lnames = load(file = "coexpression_input_Tfas_vsd_10c12s.RData");
# Load network data saved in the second part.
lnames = load(file = "coexpression_network_Tfas_vsd_10c12s..RData");
annot = read.delim("orthogroups_Tfas_Tlei_Acom.per_gene.with_functional_info.no_TEs.txt",
header = F, sep = "\t")
annot[,1] <- substring(annot[,1],1,14)
# Match probes in the data set to the probe IDs in the annotation file
probes = colnames(datExpr)
probes2annot = match(probes, annot$V1)
# Get the corresponding Locuis Link IDs
Gene_GOterms = annot$V5[probes2annot];
sing_mods <- read.csv("Table_modules_sign_time_Tfas.csv", header = T)
View(sing_mods)
sign_mods <- read.csv("Table_modules_sign_time_Tfas.csv", header = T)
modNames <- substring(rownames(sign_mods), 3)
sign_mods <- read.csv("Table_modules_sign_time_Tfas.csv", header = T, row.names = 1)
View(sign_mods)
modNames <- substring(rownames(sign_mods), 3)
for (module in modNames){
# Select module probes
modGenes = (moduleColors==module)
# Get their entrez ID codes
modGOs = Gene_GOterms[modGenes];
# Write them into a file
fileName = paste("GOterms-", module, ".txt", sep="");
write.table(as.data.frame(modGOs), file = fileName,
row.names = FALSE, col.names = FALSE, quote = F)
}
modGOs
library("stringr")
str_split(modGOs, ",")
modGOs <- str_split(modGOs, ",")
View(modGOs)
unlist(modGOs)
lnames <- load(file = "coexpression_network_Tfas_vsd_10c12s..RData");
# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
#Gather some info on significant modules
modules_sign_time <- as.data.frame(moduleTraitCor[moduleTraitPvalue[,2] < 0.05,])
colnames(modules_sign_time) <- c("corr_to_sample", "corr_to_time")
nr_genes_module <- table(moduleColors)
modules_sign_time$gene_count <- nr_genes_module[substring(rownames(modules_sign_time),3)]
modules_sign_time$pvalue_sample <- moduleTraitPvalue[rownames(modules_sign_time),1]
modules_sign_time$pvalue_time <- moduleTraitPvalue[rownames(modules_sign_time),2]
write.csv(modules_sign_time, file = "Table_modules_sign_time_Tfas.csv", quote = F, sep = "\t")
sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
xLabels = names(datTraits),
yLabels = names(MEs),
ySymbols = names(MEs),
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.3,
zlim = c(-1,1),
main = paste("Module-trait relationships"))
# Now I want to focus just on time differences
time = as.data.frame(datTraits$time);
names(time) = "time"
# names (colors) of the modules
modNames = substring(names(MEs), 3)
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
geneTraitSignificance = as.data.frame(cor(datExpr, time, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
names(geneTraitSignificance) = paste("GS.", names(time), sep="");
names(GSPvalue) = paste("p.GS.", names(time), sep="")
# Now create a per-gene summary of the network, containing the module, the correlation of
# each trait to the time points (significance), the p-value of the significance, and the
# membership and o-value for each module, ranked by their significance for time.
# Create the starting data frame
probes = colnames(datExpr)
geneInfo0 = data.frame(moduleColor = moduleColors,
geneTraitSignificance,
GSPvalue)
# Order modules by their significance for time
modOrder = order(-abs(cor(MEs, time, use = "p")));
# Add module membership information in the chosen order
for (mod in 1:ncol(geneModuleMembership))
{
oldNames = names(geneInfo0)
geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]],
MMPvalue[, modOrder[mod]]);
names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.weight));
geneInfo = geneInfo0[geneOrder, ]
geneInfo = geneInfo0[geneOrder, ]
# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.time));
geneInfo = geneInfo0[geneOrder, ]
View(geneInfo)
# Make gene lists for all modules that are correlated with time
modNames <- substring(rownames(modules_sign_time), 3)
for (module in modNames){
# Select module probes
modGenes = geneInfo[geneInfo$moduleColor == module]
# Write them into a file
#fileName = paste("Genes-for-Enrichment_", module, ".txt", sep="");
#write.table(as.data.frame(modGenes), file = fileName,
#row.names = FALSE, col.names = FALSE, quote = F)
}
for (module in modNames){
# Select module probes
modGenes = geneInfo[geneInfo$moduleColor == module,]
# Write them into a file
#fileName = paste("Genes-for-Enrichment_", module, ".txt", sep="");
#write.table(as.data.frame(modGenes), file = fileName,
#row.names = FALSE, col.names = FALSE, quote = F)
}
View(modGenes)
for (module in modNames){
# Select module probes
modGenes = rownames(geneInfo[geneInfo$moduleColor == module,])
# Write them into a file
#fileName = paste("Genes-for-Enrichment_", module, ".txt", sep="");
#write.table(as.data.frame(modGenes), file = fileName,
#row.names = FALSE, col.names = FALSE, quote = F)
}
for (module in modNames){
# Select module probes
modGenes = rownames(geneInfo[geneInfo$moduleColor == module,])
# Write them into a file
fileName = paste("Genes-for-Enrichment_", module, ".txt", sep="");
write.table(as.data.frame(modGenes), file = fileName,
row.names = FALSE, col.names = FALSE, quote = F)
}
for (module in modNames){
# Select module probes
modGenes = rownames(geneInfo[geneInfo$moduleColor == module,])
# Write them into a file
fileName = paste("Genes-for-Enrichment_T.fasciculata_", module, ".txt", sep="");
write.table(as.data.frame(modGenes), file = fileName,
row.names = FALSE, col.names = FALSE, quote = F)
}
# Installation and loading
# Pacman will only install missing packages
if (!require("pacman")) install.packages("pacman", repos = "
http://cran.us.r-project.org")
pacman::p_load("BiocManager", "topGO", "stringr")
# Load functions
change_names <- function(data, name_list){
colnames(data) <- name_list
return(data)
}
rename <- function(table, geneNames){
names(table) <- geneNames
return(table)
}
attach_enriched_go_genes <- function(enriched_go_with_my_genes){
enriched_go_with_my_genes.list = c()
for (i in 1:length(enriched_go_with_my_genes)){
enriched_go_with_my_genes.list = c(enriched_go_with_my_genes.list, enriched_go_with_my_genes[[i]])
}
return(enriched_go_with_my_genes.list)
}
create_orthog_list <- function(go.dataframe, per_gene){
genes <- str_split(go.dataframe[,4], ", ")
orthog.l <- vector(mode = "list", length = 300)
l = 1
for (i in genes){
orthog <- vector()
for (j in i){
new <- as.character(per_gene[per_gene$V1==j,7])
orthog <- c(orthog, new)
}
orthog_uniq <- unique(orthog)
orthog_string <- paste(orthog_uniq, collapse = ', ')
orthog.l[[l]] <- orthog_string
l = l+1
orthog <- c()
}
names(orthog.l) <- c(go.dataframe$ID)
orthog.list = attach_enriched_go_genes(orthog.l)
return(orthog.list)
}
setwd("/home/clara/Documents/GitHub/Tillandsia-compgenomics/7. Rna-seq experiment 6 timepoints/")
geneID2GO <- readMappings(file = "genes_to_GO_Tfas_orthologs.map")
GO2geneID <- inverseList(geneID2GO)
geneNames <- names(geneID2GO)
dup_genes <- read.table("Genes-for-Enrichment_T.fasciculata_darkseagreen3.txt")
geneList <- factor(as.integer(geneNames %in% dup_genes$V1))
names(geneList) <- geneNames
str(geneList)
name_list = c("GO.ID","Term","Annotated","Significant","Expected","weight01_pval", "branch")
table = as.factor(geneNames) %in% dup_genes$V1
int_table = as.integer(table)
int_fac_table = factor(int_table)
fac_table = rename(table = int_fac_table, geneNames = geneNames)
GOdata.BP = new("topGOdata", ontology = "BP", allGenes = fac_table, annot = annFUN.gene2GO, gene2GO = geneID2GO)
GOdata.MF = new("topGOdata", ontology = "MF", allGenes = fac_table, annot = annFUN.gene2GO, gene2GO = geneID2GO)
GOdata.CC = new("topGOdata", ontology = "CC", allGenes = fac_table, annot = annFUN.gene2GO, gene2GO = geneID2GO)
resultWeight01.BP = runTest(GOdata.BP, statistic = "fisher")
resultWeight01.MF = runTest(GOdata.MF, statistic = "fisher")
resultWeight01.CC = runTest(GOdata.CC, statistic = "fisher")
allRes.BP1 = GenTable(GOdata.BP, weight01_pval=resultWeight01.BP, orderBy = "weight01", ranksOf = "weight01",topNodes = 100, numChar=1000)
allRes.BP2 = cbind(allRes.BP1,"BP")
allRes.BP = change_names(data = allRes.BP2, name_list = name_list)
allRes.MF1 = GenTable(GOdata.MF, weight01_pval=resultWeight01.MF, orderBy = "weight01", ranksOf = "weight01",topNodes = 100, numChar=1000)
allRes.MF2 = cbind(allRes.MF1,"MF")
allRes.MF = change_names(data = allRes.MF2, name_list = name_list)
allRes.CC1 = GenTable(GOdata.CC, weight01_pval=resultWeight01.CC, orderBy = "weight01", ranksOf = "weight01",topNodes = 100, numChar=1000)
allRes.CC2 = cbind(allRes.CC1,"CC")
allRes.CC = change_names(data = allRes.CC2, name_list = name_list)
allRes1 = rbind(allRes.BP,allRes.MF)
allRes = rbind(allRes1, allRes.CC)
allRes[startsWith(allRes$weight01_pval, "<"),6] <- "1e-30"
allGO.BP = genesInTerm(GOdata.BP)
allGO.MF = genesInTerm(GOdata.MF)
allGO.CC = genesInTerm(GOdata.CC)
allGO = c(allGO.BP, allGO.MF, allGO.CC)
# Create final table
SAM_ANOTATION = lapply(allGO,function(x) x[x %in%  dup_genes$V1])
View(SAM_ANOTATION)
enriched_go_with_my_genes = lapply(SAM_ANOTATION[allRes[,1]], paste0, collapse = ", ")
enriched_go_with_my_genes.list = attach_enriched_go_genes(enriched_go_with_my_genes)
go.dataframe = data.frame("Category" = allRes$branch, "ID" = allRes$GO.ID, "Term" = allRes$Term,
"Genes" = as.vector(enriched_go_with_my_genes.list),
"adj_pval" = as.numeric(sub(",", ".", allRes$weight01_pval, fixed = TRUE)))
# Add orthogroups
per_gene <- read.delim(args[[4]],
sep = "\t", header = F)
per_gene <- read.delim("orthogroup_info_for_GOterm_enrichment.txt",
sep = "\t", header = F)
View(per_gene)
orthog.list <- create_orthog_list(go.dataframe, per_gene)
go.dataframe2 = data.frame("Category" = allRes$branch, "ID" = allRes$GO.ID, "Term" = allRes$Term,
"adj_pval" = as.numeric(sub(",", ".", allRes$weight01_pval, fixed = TRUE)),
"Orthogroups" = as.vector(orthog.list),
"Genes" = as.vector(enriched_go_with_my_genes.list)
)
View(go.dataframe2)
go.dataframe2$adj_pval <- as.numeric(go.dataframe2$adj_pval)
go.dataframe2.significant <- go.dataframe2[go.dataframe2$adj_pval <= 0.05,]
write.table(go.dataframe2.significant, file = args[[3]], sep = "\t",
quote = F, row.names = F)
