mean(r$unmapped_p)
r <- read.table("bio-info_phd/alignment_report_Tlei_Bowtie2_26scaffolds.txt", header = T)
r$mapping_rate <- (r$reads_mapped/(r$reads_total))*100
r$uniq_mapping_rate <- (r$uniquely_mapped/(r$reads_total))*100
r$multimapping_reads <- (r$reads_mapped - r$uniquely_mapped)
r$multimapping_p <- (r$multimapping_reads/(r$reads_total))*100
r$unmapped_p <- (r$reads_unmapped/(r$reads_total))*100
r$reads_surviving_MQ_p <- (r$surviving_MQ/(r$reads_total))*100
View(r)
mean(r$reads_total)
mean(r$surviving_MQ)
mean(r$multimapping_p)
mean(r$unmapped_p)
mean(r$error_rate)
mean(r$duplication_per)
mean(r$uniquely_mapped_p)
mean(r$uniq_mapping_rate)
mean(r$reads_surviving_MQ_p)
t <- read.table("bio-info_phd/alignment_report_Tlei_Bowtie2.txt", header = T)
t$mapping_rate <- (t$reads_mapped/(t$reads_total))*100
t$uniq_mapping_rate <- (t$uniquely_mapped/(t$reads_total))*100
t$multimapping_reads <- (t$reads_mapped - t$uniquely_mapped)
t$multimapping_p <- (t$multimapping_reads/(t$reads_total))*100
t$unmapped_p <- (t$reads_unmapped/(t$reads_total))*100
t$reads_surviving_MQ_p <- (t$surviving_MQ/(t$reads_total))*100
mean(t$surviving_MQ)
mean(t$reads_surviving_MQ_p)
View(t)
View(r)
mean(t$surviving_MQ)
mean(t$uniq_mapping_rate)
mean(t$multimapping_p)
mean(t$unmapped_p)
mean(t$error_rate)
mean(t$duplication_per)
r <- read.table("bio-info_phd/alignment_report_Tlei_Bowtie2_26scaffolds.txt", header = T)
species <- substr(r$ind, 3, 5)
r$species <- species
r$mapping_rate <- (r$reads_mapped/(r$reads_total))*100
r$uniq_mapping_rate <- (r$uniquely_mapped/(r$reads_total))*100
r$multimapping_reads <- (r$reads_mapped - r$uniquely_mapped)
r$multimapping_p <- (r$multimapping_reads/(r$reads_total))*100
r$unmapped_p <- (r$reads_unmapped/(r$reads_total))*100
r$reads_surviving_MQ_p <- (r$surviving_MQ/(r$reads_total))*100
# Make boxplots of mapping rates
# Make color palette
library(RColorBrewer)
nb.cols <- 22
mycolors <- colorRampPalette(brewer.pal(8, "Dark2"))(nb.cols)
r$species <- species
View(r)
species <- substr(r$ind, 3, 5)
r$species <- species
View(r)
species
r$species
# Same for survival rate (high quality, uniquely mapping reads)
survival_counts <- cbind(r[,c(1,12,10)])
View(survival_counts)
colnames(survival_rates) <- c("sample", "species", "Survival_reads")
colnames(survival_counts) <- c("sample", "species", "Survival_reads")
ggplot(survival_counts, aes(x = species, y = Survival_rate, color = species)) +
geom_boxplot() +
geom_jitter(shape=16, position=position_jitter(0.2)) +
ylab(label = "Percentage of reads with MQ > 20 to T.lei assembly") +
xlab(label = "Species") +
theme(legend.position="none") +
scale_fill_manual(values = mycolors) +
scale_color_manual(values = mycolors)
# Make boxplots of uniquely mapping rates
library(ggplot2)
ggplot(survival_counts, aes(x = species, y = Survival_rate, color = species)) +
geom_boxplot() +
geom_jitter(shape=16, position=position_jitter(0.2)) +
ylab(label = "Percentage of reads with MQ > 20 to T.lei assembly") +
xlab(label = "Species") +
theme(legend.position="none") +
scale_fill_manual(values = mycolors) +
scale_color_manual(values = mycolors)
ggplot(survival_counts, aes(x = species, y = Survival_reads, color = species)) +
geom_boxplot() +
geom_jitter(shape=16, position=position_jitter(0.2)) +
ylab(label = "Percentage of reads with MQ > 20 to T.lei assembly") +
xlab(label = "Species") +
theme(legend.position="none") +
scale_fill_manual(values = mycolors) +
scale_color_manual(values = mycolors)
ggplot(survival_counts, aes(x = species, y = Survival_reads, color = species)) +
geom_boxplot() +
geom_jitter(shape=16, position=position_jitter(0.2)) +
ylab(label = "Number of reads with MQ > 20 to T.lei26 assembly") +
xlab(label = "Species") +
theme(legend.position="none") +
scale_fill_manual(values = mycolors) +
scale_color_manual(values = mycolors)
r <- read.table("bio-info_phd/alignment_report_Tlei_Bowtie2_26scaffolds.txt", header = T)
View(r)
species <- substr(r$ind, 3, 5)
r$species <- species
r$mapping_rate <- (r$reads_mapped/(r$reads_total))*100
r$uniq_mapping_rate <- (r$uniquely_mapped/(r$reads_total))*100
r$multimapping_reads <- (r$reads_mapped - r$uniquely_mapped)
r$multimapping_p <- (r$multimapping_reads/(r$reads_total))*100
r$unmapped_p <- (r$reads_unmapped/(r$reads_total))*100
r$reads_surviving_MQ_p <- (r$surviving_MQ/(r$reads_total))*100
r$reads_surviving_not_DP <- r$surviving_MQ*(1-r$duplication_per)
mmean(r$reads_surviving_not_DP)
mean(r$reads_surviving_not_DP)
library(ggplot2)
## To remove individuals with low data quality / amount
boxplot(r$reads_surviving_not_DP)
ggplot(r, aes(x = "", y = reads_surviving_not_DP,)) +
geom_boxplot()
ggplot(r, aes(x = "", y = reads_surviving_not_DP,)) +
geom_boxplot()  +
geom_point(shape=16, colour = "Black") +
ylab(label = "Number of non-duplicate, surviving reads") +
xlab(label = "") + theme(legend.position="none")
ggplot(r, aes(x = "", y = reads_surviving_not_DP,)) +
geom_boxplot()  +
geom_point(shape=16, colour = "Black") +
ylab(label = "Number of non-duplicate, surviving reads") +
geom_line(y = 500000)
ggplot(r, aes(x = "", y = reads_surviving_not_DP,)) +
geom_boxplot()  +
geom_point(shape=16, colour = "Black") +
ylab(label = "Number of non-duplicate, surviving reads") +
geom_hline(yintercept=500000) +
xlab(label = "") + theme(legend.position="none")
ggplot(r, aes(x = "", y = reads_surviving_not_DP,)) +
geom_boxplot()  +
geom_jitter(shape=16, colour = "Black") +
ylab(label = "Number of non-duplicate, surviving reads") +
geom_hline(yintercept=500000) +
xlab(label = "") + theme(legend.position="none")
setwd('/Users/clara/Documents/GitHub/Tillandsia-compgenomics/7. Rna-seq experiment 6 timepoints/')
library('DESeq2')
library("vsn")
library("gplots")
library("ggplot2")
library("RColorBrewer")
library("grid")
library("gridExtra")
# Read in counts and create metadata
counts <- read.delim('counts.Tfas.6_timepoints.txt', header = T, row.names = 1)
metadata <- data.frame(sample=c(rep("Tfas_A",6), rep("Tfas_B",6), rep("Tfas_C",6),
rep("Tfas_D",6),rep("Tfas_E",6), rep("Tfas_F",6)),
time=c(rep(c("0100", "0500", "0900","1300", "1700", "2100"))))
# Turn the counts and metadata into a DESeq object
dds <- DESeqDataSetFromMatrix(countData=counts, colData=metadata, design=~time)
# Filter out lowly expressed genes: I try out several filtering thresholds both on number of counts
# per gene and number of samples. The first command filters out any gene that has less than 10 counts in more than 8 samples.
idx_10c8s<- rowSums( counts(dds, normalized=TRUE) >= 10 ) >= 8 # 20,681 genes
idx_5c8s <- rowSums( counts(dds, normalized=TRUE) >= 5 ) >= 8 # 21,964 genes
idx_10c12s <- rowSums( counts(dds, normalized=TRUE) >= 10 ) >= 12 # 19,983 genes
idx_5c12s <- rowSums( counts(dds, normalized=TRUE) >= 5 ) >= 12 # 21,106 genes
# Subset the count data
dds_10c8s <- dds[idx_10c8s,]
dds_5c8s <- dds[idx_5c8s,]
dds_10c12s <- dds[idx_10c12s,]
dds_5c12s <- dds[idx_5c12s,]
# Calculate dispersion, DE, etc.
dds_10c8s <- DESeq(dds_10c8s)
dds_5c8s <- DESeq(dds_5c8s)
dds_10c12s <- DESeq(dds_10c12s)
dds_5c12s <- DESeq(dds_5c12s)
dds <- estimateSizeFactors(dds)
idx_10c8s<- rowSums( counts(dds, normalized=TRUE) >= 10 ) >= 8 # 20,681 genes
idx_5c8s <- rowSums( counts(dds, normalized=TRUE) >= 5 ) >= 8 # 21,964 genes
idx_10c12s <- rowSums( counts(dds, normalized=TRUE) >= 10 ) >= 12 # 19,983 genes
idx_5c12s <- rowSums( counts(dds, normalized=TRUE) >= 5 ) >= 12 # 21,106 genes
# Subset the count data
dds_10c8s <- dds[idx_10c8s,]
dds_5c8s <- dds[idx_5c8s,]
dds_10c12s <- dds[idx_10c12s,]
dds_5c12s <- dds[idx_5c12s,]
# Calculate dispersion, DE, etc.
dds_10c8s <- DESeq(dds_10c8s)
dds_5c8s <- DESeq(dds_5c8s)
dds_10c12s <- DESeq(dds_10c12s)
dds_5c12s <- DESeq(dds_5c12s)
rld_10c8s <- rlog(dds_10c8s)
vsd_10c8s <- varianceStabilizingTransformation(dds_10c8s)
rld_10c12s <- rlog(dds_10c12s)
vsd_10c12s <- varianceStabilizingTransformation(dds_10c12s)
rld_5c12s <- rlog(dds_5c12s)
vsd_5c12s <- varianceStabilizingTransformation(dds_5c12s)
options(stringsAsFactors = FALSE)
library(WGCNA)
options(stringsAsFactors = FALSE)
datExpr0 <- assay(vsd_10c12s)
gsg = goodSamplesGenes(assay(vsd_10c12s), verbose = 3);
gsg$allOK
sampleTree = hclust(dist(datExpr0), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
# Plot a line to show the cut
abline(h = 30, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 30, minSize = 10)
table(clust)
# clust 1 contains the samples we want to keep.
keepSamples = (clust==1)
datExpr = datExpr0[keepSamples, ]
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
datTraits <- metadata
rownames(datTraits) <- colnames(datExpr)
# Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average")
# Network construction
allowWGCNAThreads()
# Saving data ready for network construction
save(datExpr, datTraits, file = "coexpression_input_data_vsd_10c12s.RData")
setwd('/Users/clara/Documents/GitHub/Tillandsia-compgenomics/7. Rna-seq experiment 6 timepoints/')
library("WGCNA")
# Saving data ready for network construction
save(datExpr, datTraits, file = "coexpression_input_Tfas_vsd_10c12s.RData")
# Set necessary environment for WGCNA
options(stringsAsFactors = FALSE);
allowWGCNAThreads()
# Load input data
lnames = load(file = "coexpression_input_Tfas_vsd_10c12s.RData");
# Choosing the soft threshold
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
datExpr
datTraits
View(datTraits)
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(as.numeric(datTraits), signed = FALSE);
summary(datTraits)
View(datTraits)
datTraits$sample <- as.factor(datTraits$sample)
summary(datTraits)
datTraits$time <- as.factor(datTraits$time)
summary(datTraits)
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(as.numeric(datTraits), signed = FALSE);
as.numeric(datTraits)
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);
# Choosing the soft threshold
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=40, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
# Choosing the soft threshold
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2), seq(from = 30, to = 100, by = 10))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
# Choosing the soft threshold
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2), seq(from = 30, to = 100, by = 10))
powers
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
sft$fitIndices[,1]
sft$fitIndices[,3]
sft$fitIndices[,2]
-sign(sft$fitIndices[,3])*sft$fitIndices[,2]
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
View(datExpr)
View(sft)
View(sft[["fitIndices"]])
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
sft[["fitIndices"]]
?pickSoftThreshold
assay(vsd_10c12s)
datExpr0 <- t(datExpr0)
View(datExpr0)
datExpr0
gsg = goodSamplesGenes(assay(vsd_10c12s), verbose = 3);
gsg$allOK
sampleTree = hclust(dist(datExpr0), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
# Plot a line to show the cut
abline(h = 170, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 30, minSize = 10)
table(clust)
# Plot a line to show the cut
abline(h = 160, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 30, minSize = 10)
table(clust)
# Plot a line to show the cut
abline(h = 150, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 30, minSize = 10)
table(clust)
# Plot a line to show the cut
abline(h = 145, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 30, minSize = 10)
table(clust)
# Plot a line to show the cut
abline(h = 140, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 30, minSize = 10)
table(clust)
# Plot a line to show the cut
abline(h = 130, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 30, minSize = 10)
table(clust)
# Plot a line to show the cut
abline(h = 120, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 30, minSize = 10)
table(clust)
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 140, minSize = 10)
table(clust)
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 145, minSize = 10)
table(clust)
# clust 1 contains the samples we want to keep.
keepSamples = (clust==1)
datExpr = datExpr0[keepSamples, ]
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
datTraits <- metadata
rownames(datTraits) <- colnames(datExpr)
rownames(datTraits) <- rownames(datExpr)
rownames(datExpr)
View(gsg)
View(metadata)
datTraits <- metadata[-c(12,36),]
rownames(datTraits) <- rownames(datExpr)
# Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);
datTraits$sample <- as.factor(datTraits$sample)
datTraits$time <- as.factor(datTraits$time)
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);
# Saving data ready for network construction
save(datExpr, datTraits, file = "coexpression_input_Tfas_vsd_10c12s.RData")
# Load input data
lnames = load(file = "coexpression_input_Tfas_vsd_10c12s.RData");
# Choosing the soft threshold
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5, networkType = "signed")
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
# Choosing the soft threshold
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5, networkType = "signed")
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.85,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
# Now, we prepare the data for use in WGCNA
plotPCA(vsd_10c12s, intgroup=c("time", "sample"))
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.85,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
